# 散列表(哈希表)

## 掌握程度

-   代码实现一个拉链法解决冲突的散列表

## 代码实现

-   同上
-   实现一个 LRU 缓存淘汰算法

## 概念

-   散列表来源于数组,借助散列函数对数组这种数据结构进行扩展,利用的是数组支持按照下标随机访问元素时间复杂度是 O(1)的特性
-   用散列函数将数据的 key 值映射为下标,然后将数据存储再数组中对应下标的位置

## 散列函数的基本要求

-   散列函数计算得到的散列值是一个非负整数(用作数组下标)
-   若 key1===key2.则 hash(key1)===hash(key2)
-   若 key1!==key2.则 hash(key1)!==hash(key2)

### 原则

-   尽可能让散列后的值随机且均匀分布,这样会减少散列冲突
-   散列函数设计不能太过复杂,防止损耗时间
-   常见方法:直接寻址,平方取中,折叠,随机数

## 散列冲突的解决方式

-   开放寻址法
    -   核心思想:如果出现散列冲突,就重新探测一个空闲位置,将其插入
    -   常见方式:
        -   线性探测:插入时如果位置已经被占用,则从当前位置依次向后查找
        -   二次探测:线性探测每次步长为 1,二次探测步长为其平方
        -   双重散列:使用一组散列函数,直到找到空闲位置位置
    -   优点:
        -   数组存储在数组中,可以有效利用 cpu 缓存
        -   易序列化
    -   缺点
        -   删除麻烦
        -   冲突时的代价更高
    -   应用:更适合数据量小,装载因子小
-   链表法
    -   核心思想:散列表中,每个槽位对应一条链表,,所有散列表值相同的元素都放到相同槽位的链表中
    -   优点:
        -   更灵活,支持更多的优化策略
    -   缺点:
        -   更加消耗内存,对 cpu 缓存也不友好
    -   应用:适合大对象,大数据量的散列表

## 优化 LRU 缓存淘汰算法(链表)
