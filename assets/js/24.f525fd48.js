(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{1073:function(v,_,t){"use strict";t.r(_);var a=t(71),l=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"堆"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[v._v("#")]),v._v(" 堆")]),v._v(" "),t("h2",{attrs:{id:"掌握程度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#掌握程度"}},[v._v("#")]),v._v(" 掌握程度")]),v._v(" "),t("ul",[t("li",[v._v("能代码实现堆,堆排序并掌握堆的三种应用\n"),t("ul",[t("li",[v._v("优先级队列")]),v._v(" "),t("li",[v._v("Top K")]),v._v(" "),t("li",[v._v("中位数")])])])]),v._v(" "),t("h2",{attrs:{id:"代码实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码实现"}},[v._v("#")]),v._v(" 代码实现")]),v._v(" "),t("ul",[t("li",[v._v("实现一个小顶堆,大顶堆,优先级队列")]),v._v(" "),t("li",[v._v("实现堆排序")]),v._v(" "),t("li",[v._v("利用优先级队列合并 K 个有序数组")]),v._v(" "),t("li",[v._v("求一组动态数据集合的最大 Top K")])]),v._v(" "),t("h2",{attrs:{id:"概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[v._v("#")]),v._v(" 概念")]),v._v(" "),t("ul",[t("li",[v._v("堆是一个完全二叉树")]),v._v(" "),t("li",[v._v("堆中的每个节点的值必须大于等于(或小于等于)其子树中每个节点的值")])]),v._v(" "),t("h2",{attrs:{id:"操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#操作"}},[v._v("#")]),v._v(" 操作")]),v._v(" "),t("h3",{attrs:{id:"往堆中插入一个元素"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#往堆中插入一个元素"}},[v._v("#")]),v._v(" 往堆中插入一个元素")]),v._v(" "),t("ul",[t("li",[v._v("堆化:将不满足堆特性的数组调整到满足的过程\n"),t("ul",[t("li",[v._v("顺着节点所在的路径,向上或向下,对比,然后交换")])])]),v._v(" "),t("li",[v._v("过程\n"),t("ul",[t("li",[v._v("让新插入的节点与父节点比对大小")]),v._v(" "),t("li",[v._v("如果不满足子节点小于等于父节点的大小关系,就互换两个节点")]),v._v(" "),t("li",[v._v("重复这个过程")])])])]),v._v(" "),t("h3",{attrs:{id:"删除堆顶元素"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#删除堆顶元素"}},[v._v("#")]),v._v(" 删除堆顶元素")]),v._v(" "),t("ul",[t("li",[v._v("过程\n"),t("ul",[t("li",[v._v("将最后一个节点放到堆顶,然后堆化")])])])]),v._v(" "),t("h2",{attrs:{id:"堆排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆排序"}},[v._v("#")]),v._v(" 堆排序")]),v._v(" "),t("ul",[t("li",[v._v("堆排序是一种原地的,时间复杂度为 O(nlogn)的排序算法")])]),v._v(" "),t("h3",{attrs:{id:"步骤"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#步骤"}},[v._v("#")]),v._v(" 步骤")]),v._v(" "),t("ul",[t("li",[v._v("原地建堆\n"),t("ul",[t("li",[v._v("思路一:将第一个元素放在数组下标 1 的位置,调用堆的插入操作,,将 2-n 依次插入")]),v._v(" "),t("li",[v._v("※思路二:\n"),t("ul",[t("li",[v._v("将下标 n/2=>1 的数据进行堆化")]),v._v(" "),t("li",[v._v("n/2+1=>n 是叶子节点,不需要堆化(完全二叉树)")]),v._v(" "),t("li",[v._v("时间复杂度:O(n)(仅建堆操作)")])])])])]),v._v(" "),t("li",[v._v("排序(大顶堆)\n"),t("ul",[t("li",[v._v("此时最大值在堆顶,将其与最后一个元素交换,即最大元素放在下标为 n 的位置")]),v._v(" "),t("li",[v._v("将剩下 n-1 个元素堆化,然后其中的最大值与最后交换,即放在 n-1 的位置")]),v._v(" "),t("li",[v._v("重复这个操作,知道堆中只剩下下标为 1 的一个元素")]),v._v(" "),t("li",[v._v("时间复杂度:O(nlogn)")])])])]),v._v(" "),t("h3",{attrs:{id:"缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[v._v("#")]),v._v(" 缺点")]),v._v(" "),t("ul",[t("li",[v._v("堆化时跳着访问数据,不利于 cpu 缓存")]),v._v(" "),t("li",[v._v("同样的数据,数据交换次数大于快速排序")]),v._v(" "),t("li",[v._v("建堆时会打乱原有顺序")])]),v._v(" "),t("h2",{attrs:{id:"应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#应用"}},[v._v("#")]),v._v(" 应用")]),v._v(" "),t("h3",{attrs:{id:"优先级队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优先级队列"}},[v._v("#")]),v._v(" 优先级队列")]),v._v(" "),t("ul",[t("li",[v._v("概念:按照优先级,优先级高的先出")]),v._v(" "),t("li",[v._v("具体应用\n"),t("ul",[t("li",[v._v("合并有序小文件:将小文件中的字符串取出放入小顶堆,堆顶元素,即优先级队列队首元素即最小字符串,将其放入大文件中,并将其从堆中删除,然后再从小文件中取出洗衣歌字符串放入堆中")]),v._v(" "),t("li",[v._v("高性能定时器:按照设定时间存储在小顶堆中,队首即最先执行的任务,用其时间点与当前时间相减获取间隔 T ,T s 之后第一个任务执行并删除堆顶元素,重新计算新的时间差值")])])])]),v._v(" "),t("h3",{attrs:{id:"求-topk"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#求-topk"}},[v._v("#")]),v._v(" 求 topK")]),v._v(" "),t("ul",[t("li",[v._v("维护一个大小为 K 的小顶堆,从数组中取出数据插入队中,堆满后继续取数据与堆顶元素比较,比堆顶大,则删除堆顶元素,并将该元素插入堆中")])]),v._v(" "),t("h3",{attrs:{id:"求中位数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#求中位数"}},[v._v("#")]),v._v(" 求中位数")]),v._v(" "),t("ul",[t("li",[v._v("维护两个堆,一个大顶堆存储前半部分数据,剩下存储在小顶堆中,且小顶堆中的数据都大于大顶堆中的数据")]),v._v(" "),t("li",[v._v("总数为偶数时,大顶堆保留 n/2 个数据,奇数时 n/2+1")]),v._v(" "),t("li",[v._v("此时,大顶堆堆顶元素为中位数")]),v._v(" "),t("li",[v._v("新增数据时,小于等于大顶堆的堆顶元素,即插入大顶堆中,否则插入小顶堆中")]),v._v(" "),t("li",[v._v("若两个堆中数量不符合 50%,则多的那一方的堆顶元素挪到另一方")])])])}),[],!1,null,null,null);_.default=l.exports}}]);