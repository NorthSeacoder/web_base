# 原地排序

- 特指空间复杂度是O(1)的算法
- 冒泡,插入,选择

## 如何分析一个排序算法

### 执行效率

- 最好,最坏,平均情况时间复杂度
- 时间复杂度的系数
- 比较次数,交换(移动)次数

### 稳定性

- 概念:如果待排序的序列中存在值相等的元素,经过排序后,相等元素之间原有的先后顺序不变
- 应用:可针对对象的多种属性进行有优先级的排序

### 内存损耗

- 通过空间复杂度来衡量 

## 冒泡排序

### 概念

- 只操作相邻的两个数据,每次冒泡操作会对相邻的两个元素进行比较
- 一次冒泡会让至少一个元素移动到正确位置
- 优化:若某次冒泡不存在数据交换,则说明已经达到完全有序,不用再执行后续的冒泡操作

### 稳定性

- 冒泡排序是稳定的排序算法

### 时间复杂度

- 最好:O(n),最坏:O(n²)

### 实现

```js

```

## 插入排序

### 概念

- 将数组分为已排序区间和未排序区间,初始已排序区间只有一个元素,即数组的第一个元素,在未排序区间取出一个插入到已排序区间的正确位置,直到未排序区间为空

### 稳定性

- 插入排序是稳定的排序算法

### 时间复杂度

- 最好:O(n),最坏:O(n²)

### 相比冒泡排序的优势

- 尽管时间复杂度相同,但就代码实现上来看,冒泡的数据交换比插入更为复杂,赋值操作更多

### 实现

```js

```

## 选择排序

### 概念

- 将数组分为已排序区间和未排序区间,初始已排序区间为空,每次在未排序区间取出一个最小元素与未排序区间第一个元素交换位置 ,知道未排序区间为空

### 稳定性

- 选择排序不是稳定的排序算法

### 时间复杂度

- 最好:O(n²),最坏:O(n²)

### 实现

```js

```

