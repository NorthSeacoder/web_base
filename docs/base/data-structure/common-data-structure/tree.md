# 树

## 常用概念

-   节点:树中的每个元素称为节点
-   父子关系:相邻节点的连线
-   根节点:没有父节点的节点
-   叶子节点:没有子节点的节点
-   兄弟节点:具有相同父节点的多个节点
-   节点高度:节点到叶子节点的最长路径包含的边数
-   深度:根节点到节点的路径所包含的边数
-   层数:节点的深度+1
-   树的高度:根节点的高度/任一节点深度+高度

## 二叉树

### 概念

-   二叉树:每个节点最多只有两个子节点的树
-   满二叉树:除了叶子节点,每个节点都有左右两个子节点的二叉树
-   完全二叉树:叶子节点都在最下两层,最后一层叶子节点都为左节点,且除了最后一层其它层为满二叉树

### 存储

#### 链式存储

-   每个节点由三个字段组成,数据以及分别指向左右子节点的指针

#### 数组存储

-   根节点存储在下标为 1 的位置,左子节点为 2,右子节点为 3,即,节点下标为 i,其左子节点下标为 2i,右子节点下标为 2i+1,父节点为 i/2

### 遍历

#### 前序遍历

-   先遍历本身,再遍历左子树,最后遍历右子树
-   递推公式

```js
preOrder(r) = handle(r), preOrder(r.left), preOrder(r.right);
```

- 实现
```js
//递归实现

//迭代实现1-栈

//迭代实现 2-先左
```
#### 中序遍历

-   先遍历左子树,再遍历本身,最后遍历右子树
-   递推公式

```js
inOrder(r) = inOrder(r.left), handle(r), preOrder(r.right);
```
- 实现
```js
//递归

//迭代,左子树
```
#### 后序遍历

-   先遍历左子树,再遍历右子树,最后是本身
-   递推公式

```js
postOrder(r) = postOrder(r.left), posteOrder(r.right), handle(r);
```

#### 时间复杂度

-   每个节点的最多被访问两次,故时间复杂度是 O(n)


## 二叉搜索树

### 概念
树中的任意一个节点,其左子树中的每个节点的值都小于这个节点的值,而右子树节点的值都大于这个节点的值
### 特点
支持动态数据集合的快速插入,删除,查找操作
### 操作

- 查找
```js


```
- 插入
```js


```
- 删除
```js
//注意三种情况
//注意删除后的平衡因子

```
- 查找最大节点和最小节点
```js


```

- 查找前驱结点和后继节点
```js


```
## 红黑树
### 概念
- 根节点是黑色的
- 每个叶子节点都是黑色的空节点(叶子节点不存储数据)
- 任何相邻的节点都不能同为红色(指同一路径上的节点)
- 每个节点,从该节点到达其可达叶子节点的所有路径,都包含相同的黑色节点

#### 演变
- 起源为二叉查找树,但容易退化为链表
- 产生 2-3 树
    - 定义:
        - 二叉查找树的变种,有 2-,3-两种节点
        - 2-节点为普通节点,即包含一个元素,两条子连接
        - 3-节点是包含2 个元素和 3 条连接
    - 构造
        - 值插入 2-节点,2-节点扩充为 3-节点
        - 插入 3-节点
            - 该节点为根节点,将其扩充为 4-节点,然后分解为一课二叉树
            - 3-节点有一个 2-节点的父节点,将其扩充为 4-节点,然后分解,将新树的父节点融入原父节点生成 3-节点
            - 3-节点有一个 3-父节点,3-节点扩充为 4-节点,分解,新树节点融入原父节点变成 4-节点,父节点分解,行程新的二叉树,如果父节点为根节点,则再加一层
    - 优点:保持平衡,性能良好
    - 缺点:代码复杂,处理情况多,同时维护两种不同的节点
- 产生红黑树
    - 红黑树中,所有节点都是 2-节点,为了体现出 3-节点,将 3-节点的两个元素用左斜红斜线连接,即连接了两个 2-节点来表示一个 3-节点
    - 该红色斜线指向的节点为红色节点